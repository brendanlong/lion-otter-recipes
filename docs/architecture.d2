# Lion+Otter Recipes - Architecture Diagram

direction: down

title: {
  label: Lion+Otter Recipes Architecture
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
  }
}

# External Services
external: {
  label: External Services
  style: {
    fill: "#f0f0f0"
    stroke: "#999"
  }

  anthropic: {
    label: Anthropic API
    shape: rectangle
    style: {
      fill: "#d4a03c"
    }
  }

  web: {
    label: Recipe Websites
    shape: rectangle
  }

  firebase: {
    label: Firebase
    shape: rectangle
    style: {
      fill: "#ffca28"
    }
    tooltip: "Firebase Auth (Google Sign-In), Cloud Firestore (recipes + meal plans), and Cloud Storage (recipe images). Firestore uses unlimited persistent cache with auto index creation. Storage images are cached locally for offline access."
  }

}

# Android App
app: {
  label: Android App
  style: {
    fill: "#e0f2f7"
    stroke: "#2a7b9b"
    stroke-width: 2
  }

  # UI Layer
  ui: {
    label: UI Layer (Compose)
    style: {
      fill: "#fff3e0"
      stroke: "#d4a03c"
    }

    screens: {
      label: Screens
      style: {
        fill: "#ffffff"
      }

      login: {
        label: LoginScreen
        tooltip: "Google Sign-In screen shown when user is not authenticated. Gates access to the main app."
      }
      list: RecipeListScreen
      detail: {
        label: RecipeDetailScreen
        tooltip: "Displays recipe details with edit (pencil icon), share menu (Markdown text or .lorecipes file), favorite, and delete buttons. All text is selectable. Includes editable user notes section with auto-save."
      }
      edit: {
        label: EditRecipeScreen
        tooltip: "Recipe edit screen with four sections: (1) Image section — pick from gallery or remove, saved directly without AI. (2) Title and source URL fields — edited directly, saved without AI when recipe body is unchanged. (3) AI instructions — optional text field for user instructions to the AI (e.g. 'Make this recipe vegan'), included in the AI prompt when non-empty. (4) Recipe body markdown editor — when body changes or AI instructions are provided, AI cleans up formatting and regenerates structured data (densities, etc.) with existing ingredient densities passed as hints for cheaper AI models. Includes model selection and extended thinking toggle. Also supports regeneration from original source via refresh icon (when original HTML or source URL is available). Save as Copy creates a new recipe from the edited markdown instead of updating the existing one."
      }
      add: AddRecipeScreen
      settings: SettingsScreen
      import_debug_list: {
        label: ImportDebugListScreen
        tooltip: "Lists all import debug entries with status, timestamp, and model info. Only accessible when import debugging is enabled."
      }
      import_debug_detail: {
        label: ImportDebugDetailScreen
        tooltip: "Tabbed detail view for a single import debug entry. Tabs: Summary (URL, lengths, tokens, model, cost, recipe link), Original Content (HTML with source toggle), Cleaned Content (HTML with source toggle), AI Output (JSON tree view with copy-to-clipboard button). All text is selectable."
      }

      meal_plan: {
        label: MealPlanScreen
        tooltip: "Weekly meal planner view. Shows meals grouped by day with swipe-to-delete, swipe-to-edit, and long-press menu (edit/delete). Recipe selector bottom sheet with search, tag filter, date picker, meal type selector, and servings. Supports edit mode to modify date, meal type, servings, and recipe of existing entries."
      }

      grocery_list: {
        label: GroceryListScreen
        tooltip: "Two-step grocery list generator. Step 1: Select recipes from meal plan entries (grouped by date/meal type, with select all/deselect all). Step 2: View aggregated ingredient list with deduplication across recipes, check-off support (top-level hides all, sub-item reduces count), and share as Markdown."
      }

      import_selection: {
        label: ImportSelectionScreen
        tooltip: "Shared recipe selection screen for all import types (Paprika, .lorecipes). Shows checklist of recipes found in file, sorted alphabetically. Recipes checked by default unless already in app (by ID or name). Import button disabled when nothing selected. Select All / Deselect All buttons. Single new .lorecipes recipes are auto-imported without showing selection."
      }

      list -> detail: tap recipe
      detail -> edit: tap edit (pencil icon)
      list -> add: tap +
      list -> settings: tap gear
      list -> meal_plan: tap calendar
      meal_plan -> detail: tap recipe
      meal_plan -> grocery_list: tap cart icon
      add -> import_selection: pick file (.lorecipes / .paprikarecipes)
      settings -> import_selection: pick file (.lorecipes / .paprikarecipes)
      import_selection -> list: import started
      add -> settings: no API key
      settings -> import_debug_list: view debug data
      import_debug_list -> import_debug_detail: tap entry
      import_debug_detail -> detail: view recipe
    }

    components: {
      label: Shared Components
      style: {
        fill: "#ffffff"
      }

      top_bar: RecipeTopAppBar
      error_card: ErrorCard
      progress_card: ProgressCard
      status_card: StatusCard
      delete_dialog: DeleteConfirmationDialog
      cancel_import_dialog: CancelImportConfirmationDialog
      account_section: {
        label: AccountSection
        tooltip: "Settings component showing signed-in email and sign-out button with confirmation dialog warning about local cache deletion."
      }
    }

    screens -> components: uses

    viewmodels: {
      label: ViewModels
      style: {
        fill: "#ffffff"
      }

      login_vm: {
        label: LoginViewModel
        tooltip: "Manages Google Sign-In loading state. Delegates to AuthService."
      }
      list_vm: RecipeListViewModel
      detail_vm: RecipeDetailViewModel
      edit_vm: {
        label: EditRecipeViewModel
        tooltip: "Manages edit recipe screen state. Supports direct image editing (saved immediately without AI). Separates title, source URL, AI instructions, and recipe body: title/URL changes are saved directly without AI, while body changes or non-empty AI instructions trigger AI re-parsing via RecipeEditWorker. AI instructions are optional free-text (e.g. 'Make this recipe vegan') passed through the worker to the AI prompt. Defaults to the separate edit model setting (default: Sonnet) rather than the import model. Tracks model/thinking settings. Supports save as copy and regeneration from original source via RecipeRegenerateWorker. Uses ImageDownloadService to save picked images from gallery."
      }
      add_vm: AddRecipeViewModel
      settings_vm: SettingsViewModel
      zip_vm: {
        label: ZipExportImportViewModel
        tooltip: "Manages .lorecipes file export operations via WorkManager. Import is handled by ImportSelectionViewModel."
      }
      import_debug_list_vm: {
        label: ImportDebugListViewModel
        tooltip: "Observes all import debug entries from the repository as a StateFlow."
      }
      import_debug_detail_vm: {
        label: ImportDebugDetailViewModel
        tooltip: "Loads a single import debug entry by ID from SavedStateHandle."
      }
      meal_plan_vm: {
        label: MealPlanViewModel
        tooltip: "Manages weekly meal plan view state, add/edit dialog, and CRUD operations for meal plan entries. Supports editing existing entries (date, meal type, servings, recipe). Respects user's start-of-week setting from preferences."
      }
      grocery_list_vm: {
        label: GroceryListViewModel
        tooltip: "Manages grocery list generation from meal plan. Two-step flow: recipe selection (from all meal plan entries) then aggregated ingredient display with check-off and share-as-Markdown support. Non-persistent state."
      }
      import_selection_vm: {
        label: ImportSelectionViewModel
        tooltip: "Shared ViewModel for import recipe selection. Parses import files (Paprika, .lorecipes) to extract recipe names, checks for duplicates against existing recipes, and manages selection state. Enqueues WorkManager jobs for all import types and registers in-progress entries via InProgressRecipeManager."
      }
    }

    state: {
      label: UI State
      style: {
        fill: "#ffffff"
      }

      in_progress_mgr: {
        label: InProgressRecipeManager
        tooltip: "Database-backed import queue. Tracks recipes currently being imported via PendingImportEntity in Room. Observes WorkManager to update import status (metadata fetch, AI parsing, saving) and auto-clean completed entries. Supports canceling individual imports. Persists across app restarts."
      }
    }

    screens.login -> viewmodels.login_vm
    screens.list -> viewmodels.list_vm
    screens.detail -> viewmodels.detail_vm
    screens.edit -> viewmodels.edit_vm
    screens.add -> viewmodels.add_vm
    screens.settings -> viewmodels.settings_vm
    screens.settings -> viewmodels.zip_vm: backup/restore
    screens.meal_plan -> viewmodels.meal_plan_vm
    screens.grocery_list -> viewmodels.grocery_list_vm
    screens.import_debug_list -> viewmodels.import_debug_list_vm
    screens.import_debug_detail -> viewmodels.import_debug_detail_vm
    screens.import_selection -> viewmodels.import_selection_vm
    viewmodels.list_vm -> state.in_progress_mgr: observes, cancel
    viewmodels.add_vm -> state.in_progress_mgr: adds entries
    state.in_progress_mgr -> background.worker: observes status
    state.in_progress_mgr -> data.repository.pending_import_repo: CRUD
  }

  # Background Processing Layer
  background: {
    label: Background Processing
    style: {
      fill: "#f3e5f5"
      stroke: "#9c27b0"
    }

    worker: {
      label: WorkManager
      style: {
        fill: "#ffffff"
      }

      base_worker: {
        label: BaseRecipeWorker
        tooltip: "Abstract base class providing shared foreground notification management and error/unavailable result handling for all recipe workers."
      }
      import_worker: {
        label: RecipeImportWorker
        tooltip: "CoroutineWorker that handles recipe import in background. Survives app closure and shows progress notifications. Supports queue of multiple imports."
      }
      regenerate_worker: {
        label: RecipeRegenerateWorker
        tooltip: "CoroutineWorker that re-parses a recipe from its stored original HTML using the AI. Supports selecting a different model and thinking mode. Overwrites the existing recipe, preserving ID, favorite status, and creation timestamp."
      }
      edit_worker: {
        label: RecipeEditWorker
        tooltip: "CoroutineWorker that processes user-edited recipe markdown through AI re-parsing via EditRecipeUseCase. Preserves recipe metadata (ID, favorite, image, source URL, original HTML). Supports save-as-copy mode which creates a new recipe with a fresh ID."
      }
      paprika_import_worker: {
        label: PaprikaImportWorker
        tooltip: "Imports recipes from a Paprika export file (.paprikarecipes). Parses ZIP of gzip-compressed JSON, sends content through AI pipeline."
      }
      zip_export_worker: {
        label: ZipExportWorker
        tooltip: "Exports all recipes to a ZIP file using RecipeSerializer (recipe.json + original.html + recipe.md per recipe)."
      }
      zip_import_worker: {
        label: ZipImportWorker
        tooltip: "Imports recipes from a ZIP file. Reads recipe.json from each folder, skips duplicates, optionally restores original HTML."
      }
      import_worker -> base_worker: extends
      regenerate_worker -> base_worker: extends
      edit_worker -> base_worker: extends
      paprika_import_worker -> base_worker: extends
      zip_export_worker -> base_worker: extends
      zip_import_worker -> base_worker: extends
      work_ext: {
        label: "observeWorkByTag()"
        tooltip: "WorkManager extension function that encapsulates the common pattern of observing work by tag and filtering to a specific work ID. Used by AddRecipeViewModel, RecipeDetailViewModel (regenerate), and ZipExportImportViewModel."
      }
    }

    notification: {
      label: Notifications
      style: {
        fill: "#ffffff"
      }

      helper: {
        label: RecipeNotificationHelper
        tooltip: "Manages notification channel, foreground info for workers, and shows progress/success/error notifications for recipe imports and ZIP operations"
      }
    }

    worker.import_worker -> notification.helper: notify progress
    worker.regenerate_worker -> notification.helper: notify progress
    worker.edit_worker -> notification.helper: notify progress
    worker.paprika_import_worker -> notification.helper: notify progress
    worker.zip_export_worker -> notification.helper: notify progress
    worker.zip_import_worker -> notification.helper: notify progress
  }

  # Domain Layer
  domain: {
    label: Domain Layer
    style: {
      fill: "#e8f5e9"
      stroke: "#4caf50"
    }

    usecases: {
      label: Use Cases
      style: {
        fill: "#ffffff"
      }

      import: ImportRecipeUseCase
      parse_html: {
        label: ParseHtmlUseCase
        tooltip: "Central AI parsing use case. parseHtml() extracts content from HTML via Readability4J then delegates to parseText(). parseText() sends pre-extracted text to AI, builds Recipe, saves debug data. Used by URL import, Paprika import, and regeneration."
      }
      import_paprika: {
        label: ImportPaprikaUseCase
        tooltip: "Imports recipes from Paprika export (.paprikarecipes). Uses Message Batches API for multiple recipes (50% cheaper): prepares all recipes, submits as a single batch, polls for completion, processes results. Falls back to sequential processing for single recipes or when batch creation fails. Resolves images by priority: base64 photo_data (saved directly to local storage), image_url, or og:image from source page. Supports cooperative cancellation — cancels batch on server and preserves already-imported recipes."
      }
      export_zip: {
        label: ExportToZipUseCase
        tooltip: "Exports all recipes to a ZIP file using RecipeSerializer. Includes recipe images as binary files in each recipe folder."
      }
      export_single: {
        label: ExportSingleRecipeUseCase
        tooltip: "Exports a single recipe to a .lorecipes file (ZIP format) for sharing. Uses RecipeSerializer for consistent format. Includes recipe image if available."
      }
      import_zip: {
        label: ImportFromZipUseCase
        tooltip: "Imports recipes from a ZIP file. Reads recipe.json from each folder, skips duplicates by ID, optionally restores original HTML."
      }
      regenerate: {
        label: RegenerateRecipeUseCase
        tooltip: "Re-parses a recipe from its stored original HTML via ParseHtmlUseCase.parseHtml(). If no cached HTML exists, fetches fresh HTML from the recipe's source URL via WebScraperService. Passes model/thinking overrides as parameters, preserves recipe ID, favorite status, and creation timestamp."
      }
      edit_recipe: {
        label: EditRecipeUseCase
        tooltip: "Edits a recipe by sending user-modified markdown text through ParseHtmlUseCase.parseText() for AI re-parsing. Supports optional AI instructions (e.g. 'Make this recipe vegan') appended to the user message. Collects existing ingredient densities and passes them as hints to the AI, enabling cheaper models (like Haiku) to reuse known values. Preserves recipe ID, createdAt, favorite status, image, source URL, and original HTML (for future regeneration). Supports saveAsCopy mode which generates a new UUID and fresh timestamps for the copied recipe."
      }
      aggregate_grocery: {
        label: AggregateGroceryListUseCase
        tooltip: "Aggregates ingredients from selected meal plan recipes into a deduplicated grocery list. Normalizes ingredient names by removing size prefixes (small/medium/large). Uses Recipe.aggregateIngredients() which sums amounts in base units (grams/mL) via shared BaseUnitAccumulator to handle mixed-unit ingredients correctly."
      }
      tags: {
        label: GetTagsUseCase
        tooltip: "Selects top k tags using ILP optimization (ojalgo) to maximize coverage while penalizing generic tags. Falls back to greedy set cover if solver fails."
      }
      calc_usage: {
        label: CalculateIngredientUsageUseCase
        tooltip: "Pure domain logic for calculating ingredient usage status from checked instruction steps, scale, and measurement preference."
      }
    }

    util: {
      label: Utilities
      style: {
        fill: "#ffffff"
      }

      markdown: {
        label: RecipeMarkdownFormatter
        tooltip: "Converts Recipe to human-readable Markdown format for export. Supports format() (full markdown with title/URL) and formatBody() (body only, for edit screen where title/URL are separate fields). Also provides collectDensities() and formatDensityHints() for extracting existing ingredient densities as AI hints."
      }
      serializer: {
        label: RecipeSerializer
        tooltip: "Shared logic for serializing/deserializing recipes in the standard folder export format (recipe.json + original.html + recipe.md + image.*). Used by ZIP export/import."
      }
      zip_import_helper: {
        label: ZipImportHelper
        tooltip: "Shared helper for importing recipes and meal plans from ZIP files. Consolidates ZIP reading (text + image files), recipe import (deserialize, deduplicate, import bundled image or download, save), and meal plan import logic. Used by ImportFromZipUseCase and ImportSelectionViewModel."
      }
      serializer -> markdown: format
      zip_import_helper -> serializer: deserialize
    }

    models: {
      label: Domain Models
      style: {
        fill: "#ffffff"
      }

      recipe: {
        label: Recipe
        tooltip: "@Immutable. Fields: id, name, sourceUrl, story, servings, times, ingredients, instructions, equipment, tags, imageUrl (gs:// URI pointing to Firebase Storage, synced across devices via Firestore; Coil fetcher resolves to local cache), sourceImageUrl (original remote URL), timestamps, isFavorite, userNotes (free-form user notes, preserved across AI edits/regeneration, included in markdown sent to AI)"
      }
      ingredient: {
        label: Ingredient
        tooltip: "@Immutable. Fields: name, notes, alternates, amounts, optional"
      }
      instruction: {
        label: InstructionStep
        tooltip: "@Immutable. Fields: stepNumber, instruction, ingredients, optional"
      }
      section: IngredientSection
      measurement: Measurement
      measurement_type: MeasurementType
      measurement_pref: MeasurementPreference
      unit_system: {
        label: UnitSystem
        tooltip: "Enum: METRIC, CUSTOMARY. Used for volume and weight unit preferences separately."
      }
      usage_status: {
        label: IngredientUsageStatus
        tooltip: "@Immutable. Fields: totalAmount, usedAmount, unit, isFullyUsed, remainingAmount"
      }
      meal_plan_entry: {
        label: MealPlanEntry
        tooltip: "@Immutable @Serializable. Fields: id, recipeId, recipeName, recipeImageUrl, date, mealType, servings, createdAt, updatedAt"
      }
      meal_type: {
        label: MealType
        tooltip: "Enum: BREAKFAST, LUNCH, SNACK, DINNER with displayOrder for sorting"
      }
      start_of_week: {
        label: StartOfWeek
        tooltip: "Enum: LOCALE_DEFAULT, MONDAY..SUNDAY. User preference for which day the week starts on in the meal planner. LOCALE_DEFAULT resolves to device locale's first day of week."
      }
      ingredient_formatter: {
        label: IngredientFormatter
        tooltip: "Shared formatting functions for ingredient amounts: formatQuantity (fractions), formatWeightQuantity (decimals), formatLbOz (compound lb+oz), formatAmount (convenience). Used by Ingredient.format(), IngredientSectionContent, RecipeMarkdownFormatter, and GroceryListViewModel."
      }
      ingredient_aggregation: {
        label: IngredientAggregation
        tooltip: "Shared BaseUnitAccumulator for summing ingredient amounts in base units (grams for weight, mL for volume). Used by Recipe.aggregateIngredients() and CalculateIngredientUsageUseCase."
      }
      meal_plan_entry -> meal_type: type

      recipe -> section
      section -> ingredient
      ingredient -> ingredient: alternates
      ingredient -> measurement: amounts
      measurement -> measurement_type: type
      recipe -> instruction
      instruction -> ingredient: step ingredients
    }

    usecases.import -> usecases.parse_html: uses
    usecases.regenerate -> usecases.parse_html: uses
    usecases.edit_recipe -> usecases.parse_html: uses
    usecases.parse_html -> data.repository.import_debug_repo: save debug data
    usecases.export_zip -> util.serializer: serialize
    usecases.export_zip -> data.remote.image_dl: read local images
    usecases.export_zip -> data.remote.image_sync: resolve storage images
    usecases.export_single -> util.serializer: serialize
    usecases.export_single -> data.remote.image_dl: read local images
    usecases.export_single -> data.remote.image_sync: resolve storage images
    usecases.import_paprika -> data.remote.image_dl: save base64 images
    usecases.import_zip -> util.zip_import_helper: import
  }

  # Data Layer
  data: {
    label: Data Layer
    style: {
      fill: "#e3f2fd"
      stroke: "#2196f3"
    }

    repository: {
      label: Repository
      style: {
        fill: "#ffffff"
      }

      repo: {
        label: RecipeRepository
        tooltip: "CRUD operations for recipes via Firestore. Uses snapshot listeners (callbackFlow) for reactive reads. Fire-and-forget writes. Original HTML stored in subcollection."
      }
      import_debug_repo: {
        label: ImportDebugRepository
        tooltip: "CRUD operations for import debug entries. Supports listing all, getting by ID, saving, and deleting all entries."
      }
      pending_import_repo: {
        label: PendingImportRepository
        tooltip: "Database-backed import queue. CRUD operations for pending recipe imports. Tracks URL, page metadata (title, image), import status, and WorkManager job ID."
      }
      meal_plan_repo: {
        label: MealPlanRepository
        tooltip: "CRUD operations for meal plan entries via Firestore. Uses snapshot listeners for reactive date-range queries. Fire-and-forget writes. WriteBatch for cascade deletes."
      }
    }

    local: {
      label: Local Storage
      style: {
        fill: "#ffffff"
      }

      room: {
        label: Room Database
        shape: cylinder
        tooltip: "Only used for local-only concerns: PendingImport (import queue) and ImportDebug (debugging data). Recipes and meal plans are stored in Firestore."
      }
      datastore: {
        label: DataStore
        shape: cylinder
      }
      tink_encrypted: {
        label: Tink Encrypted Storage
        shape: cylinder
        tooltip: "Google Tink AEAD (AES256-GCM) encrypted SharedPreferences for sensitive data like API keys. Keyset protected by Android Keystore."
        style: {
          fill: "#c8e6c9"
        }
      }
      import_debug_dao: ImportDebugDao
      pending_import_dao: PendingImportDao
      pending_import_entity: {
        label: PendingImportEntity
        tooltip: "Room entity for the import queue: id, url, name, imageUrl, status, workManagerId, errorMessage, createdAt"
      }
      import_debug_entity: {
        label: ImportDebugEntity
        tooltip: "Room entity storing import debug data: source URL, original/cleaned HTML, AI output JSON, token counts, model, error info, linked recipe ID"
      }
      image_storage: {
        label: Local Image Cache
        shape: cylinder
        tooltip: "Recipe images cached locally in app internal storage (filesDir/recipe_images/). Primary storage is Firebase Storage, referenced via gs:// URIs (e.g., gs://bucket/users/{uid}/images/{file}). Coil's FirebaseStorageCoilFetcher downloads and caches images on first display."
      }
      settings: {
        label: SettingsDataStore
        tooltip: "Uses Tink AEAD encryption for API key, DataStore for non-sensitive settings (AI model, edit model, thinking enabled, keep screen on, theme mode, volume/weight unit system preferences, grocery list volume/weight unit system preferences, start of week, import debugging enabled)"
      }

      import_debug_dao -> room
      import_debug_entity -> room
      pending_import_dao -> room
      pending_import_entity -> room
      settings -> datastore: non-sensitive settings
      settings -> tink_encrypted: API key
    }

    remote: {
      label: Remote Services
      style: {
        fill: "#ffffff"
      }

      anthropic_svc: {
        label: AnthropicService
        tooltip: "Uses the Anthropic Java SDK (OkHttp) to parse recipes with volume/weight conversions, step-level ingredient extraction, and optional field detection. Thinking is configurable via settings: uses adaptive thinking for Opus 4.6 and Sonnet 4.6, extended thinking with budget for older models. Supports Opus 4.6, Opus 4.5, Sonnet 4.5, and Haiku 4.5. Supports Message Batches API for bulk imports (Paprika): creates batch, polls for completion, streams results. Batch mode is 50% cheaper than synchronous calls."
      }
      scraper: {
        label: WebScraperService
        tooltip: Uses Readability4J to extract article content
      }
      image_dl: {
        label: ImageDownloadService
        tooltip: "Downloads recipe images from remote URLs and stores them locally in app internal storage. Automatically retries with HTTPS if an HTTP download fails (e.g., cleartext traffic not permitted). Also supports saving images from byte streams (ZIP import) and base64 data (Paprika photo_data). After saving locally, uploads images to Firebase Storage via ImageSyncService. Returns gs:// URIs for Firestore sync. Used during import, export, and ZIP restore."
      }
      image_sync: {
        label: ImageSyncService
        tooltip: "Syncs recipe images between local storage and Firebase Storage. Uploads resized images (max 2048px, JPEG 85%) to users/{uid}/images/. Downloads images to local cache for offline display. Handles orphan cleanup. Returns gs:// URIs stored in Recipe.imageUrl for cross-device sync."
      }
      storage_fetcher: {
        label: FirebaseStorageCoilFetcher
        tooltip: "Custom Coil Fetcher that intercepts Firebase Storage gs:// URIs and resolves them to local cache files. Downloads from Firebase Storage on first load, then serves from disk cache. Registered via LionOtterApp's SingletonImageLoader.Factory."
      }
      firestore_svc: {
        label: FirestoreService
        tooltip: "Singleton managing Firestore instance with unlimited persistent cache and auto index creation. Provides user-scoped collection references (recipes, mealPlans, content subcollection). Reports errors via SharedFlow for Toast display. Handles sign-out (terminate, clear persistence)."
      }
      auth_svc: {
        label: AuthService
        tooltip: "Google Sign-In via Credential Manager API. Exposes isSignedIn StateFlow for auth gating in MainActivity. Manages sign-out flow including Firestore cache clearing."
      }
    }

    dto: {
      label: DTOs
      style: {
        fill: "#ffffff"
      }

      recipe_dto: {
        label: RecipeDto
        tooltip: "Firestore DTO for recipes. Uses @DocumentId, client-set timestamps, Long for integers. Includes toDomain() and Recipe.toDto() converters."
      }
      meal_plan_dto: {
        label: MealPlanDto
        tooltip: "Firestore DTO for meal plans. Date stored as ISO-8601 string, mealType as enum name. Includes toDomain() and MealPlanEntry.toDto() converters."
      }
    }

    paprika: {
      label: Paprika
      style: {
        fill: "#ffffff"
      }

      parser: {
        label: PaprikaParser
        tooltip: "Parses Paprika export files (.paprikarecipes): ZIP of gzip-compressed JSON. Formats recipe content for AI parsing."
      }
      recipe_model: {
        label: PaprikaRecipe
        tooltip: "Data model for Paprika recipe JSON (name, ingredients, directions, notes, categories, photo_data, etc.)"
      }
    }

    repository.repo -> remote.firestore_svc: Firestore CRUD
    repository.import_debug_repo -> local.import_debug_dao
    repository.pending_import_repo -> local.pending_import_dao
    repository.meal_plan_repo -> remote.firestore_svc: Firestore CRUD
    remote.image_dl -> local.image_storage: caches images
    remote.image_dl -> remote.image_sync: upload to storage
    remote.image_sync -> local.image_storage: download cache
    remote.storage_fetcher -> remote.image_sync: resolve paths
    remote.storage_fetcher -> local.image_storage: cache read/write
  }

  # Performance
  performance: {
    label: Performance
    style: {
      fill: "#fff9c4"
      stroke: "#f9a825"
    }

    baseline_profile: {
      label: Baseline Profiles
      tooltip: "Pre-compiled critical code paths for faster startup and smoother scrolling. Generated via :baselineprofile macrobenchmark module."
    }

    profile_installer: {
      label: ProfileInstaller
      tooltip: "Installs Baseline Profiles at app install time for AOT compilation of critical paths."
    }

    baseline_profile -> profile_installer: generates rules for
  }

  # DI
  di: {
    label: Hilt DI
    style: {
      fill: "#fce4ec"
      stroke: "#e91e63"
    }

    app_module: AppModule
    db_module: DatabaseModule
    net_module: NetworkModule
    worker_module: WorkerModule
  }

  # Connections within app
  ui.viewmodels.list_vm -> data.repository.repo: recipes, delete
  ui.viewmodels.list_vm -> data.repository.meal_plan_repo: cascade delete meal plans
  ui.viewmodels.list_vm -> domain.usecases.tags: top tags
  ui.viewmodels.detail_vm -> data.repository.repo: recipe, delete, favorite
  ui.viewmodels.detail_vm -> data.repository.meal_plan_repo: cascade delete meal plans
  ui.viewmodels.detail_vm -> domain.usecases.calc_usage: ingredient usage
  ui.viewmodels.detail_vm -> domain.usecases.export_single: export .lorecipes
  ui.viewmodels.detail_vm -> data.local.settings: keep screen on, unit prefs
  ui.viewmodels.edit_vm -> data.repository.repo: recipe, original HTML, image
  ui.viewmodels.edit_vm -> data.local.settings: edit model, thinking prefs
  ui.viewmodels.edit_vm -> data.remote.image_dl: save picked images
  ui.viewmodels.edit_vm -> data.remote.image_sync: delete remote images
  ui.viewmodels.edit_vm -> background.worker.edit_worker: save edits
  ui.viewmodels.edit_vm -> background.worker.regenerate_worker: regenerate from original
  ui.viewmodels.edit_vm -> background.worker.work_ext: observe edit/regenerate
  ui.viewmodels.import_selection_vm -> data.repository.repo: check duplicates
  ui.viewmodels.import_selection_vm -> domain.util.serializer: deserialize (for selection preview)
  ui.viewmodels.import_selection_vm -> domain.util.zip_import_helper: read ZIP contents
  ui.viewmodels.import_selection_vm -> data.paprika.parser: parse export
  ui.viewmodels.import_selection_vm -> background.worker: enqueue work
  ui.viewmodels.import_selection_vm -> state.in_progress_mgr: adds entries
  ui.viewmodels.add_vm -> background.worker: enqueue work
  ui.viewmodels.add_vm -> background.worker.work_ext: observe import
  ui.viewmodels.zip_vm -> background.worker.zip_export_worker: export
  ui.viewmodels.zip_vm -> background.worker.work_ext: observe export
  ui.viewmodels.meal_plan_vm -> data.repository.meal_plan_repo: CRUD
  ui.viewmodels.meal_plan_vm -> data.repository.repo: recipe list
  ui.viewmodels.meal_plan_vm -> data.local.settings: start of week
  ui.viewmodels.meal_plan_vm -> domain.usecases.tags: top tags
  ui.viewmodels.grocery_list_vm -> data.repository.meal_plan_repo: meal plans
  ui.viewmodels.grocery_list_vm -> data.repository.repo: recipes
  ui.viewmodels.grocery_list_vm -> domain.usecases.aggregate_grocery: aggregate ingredients
  ui.viewmodels.grocery_list_vm -> data.local.settings: grocery unit prefs
  ui.viewmodels.settings_vm -> data.repository.import_debug_repo: delete debug data
  ui.viewmodels.import_debug_list_vm -> data.repository.import_debug_repo: list entries
  ui.viewmodels.import_debug_detail_vm -> data.repository.import_debug_repo: get entry
  background.worker.import_worker -> domain.usecases.import: execute
  background.worker.regenerate_worker -> domain.usecases.regenerate: execute
  background.worker.edit_worker -> domain.usecases.edit_recipe: execute
  background.worker.paprika_import_worker -> domain.usecases.import_paprika: execute
  background.worker.zip_export_worker -> domain.usecases.export_zip: execute
  background.worker.zip_import_worker -> domain.usecases.import_zip: execute
  domain.usecases -> data.repository: access data
  domain.util.zip_import_helper -> data.repository.repo: save recipe, check duplicates
  domain.util.zip_import_helper -> data.repository.meal_plan_repo: import meal plans
  domain.util.zip_import_helper -> data.remote.image_dl: download image
  domain.usecases.import_paprika -> data.paprika.parser: parse export
  domain.usecases.import_paprika -> domain.usecases.parse_html: parseText, saveBatchResult
  domain.usecases.import_paprika -> data.remote.anthropic_svc: batch API
  domain.usecases.regenerate -> data.remote.scraper: fetch HTML if not cached
  domain.usecases.import_paprika -> data.remote.scraper: fetch source image
  domain.usecases.parse_html -> data.remote.image_dl: download image
  ui.viewmodels.login_vm -> data.remote.auth_svc: sign in
  ui.viewmodels.settings_vm -> data.remote.auth_svc: sign out, email
  data.remote.firestore_svc -> external.firebase: Firestore
  data.remote.auth_svc -> external.firebase: Auth
  data.remote.image_sync -> external.firebase: Storage
  data.remote.scraper -> external.web: fetch HTML
  data.remote.image_dl -> external.web: download image
  data.remote.anthropic_svc -> external.anthropic: parse recipe
}

# Data Flow Legend
legend: {
  label: Data Flow
  near: bottom-center
  style: {
    fill: "#f5f5f5"
  }

  import_flow: {
    label: "URL Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  flow1: "1. User pastes URL and taps Import"
  flow2: "2. ViewModel enqueues WorkManager job"
  flow3: "3. RecipeImportWorker runs as foreground service"
  flow4: "4. Scraper fetches HTML, AI parses recipe"
  flow5: "5. Repository saves to Firestore (fire-and-forget)"

  flow1 -> flow2 -> flow3 -> flow4 -> flow5

  zip_flow: {
    label: ".lorecipes Export/Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  zip1: "Export: User picks save location, ZipExportWorker writes .lorecipes file"
  zip2: "Import: User picks .lorecipes file, selects recipes via ImportSelectionScreen"
  zip3: "ZipImportWorker imports selected recipes in background via WorkManager"
  zip4: "Uses RecipeSerializer for consistent format, skips duplicates by ID"

  zip1 -> zip2 -> zip3 -> zip4

  paprika_flow: {
    label: "Paprika Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  pap1: "1. User picks .paprikarecipes file, selects recipes to import"
  pap2: "2. PaprikaImportWorker parses ZIP of gzip-compressed JSON (filtered to selected)"
  pap3: "3. For multiple recipes: submit all as a batch via Message Batches API (50% cheaper, parallel)"
  pap4: "4. Poll for batch completion, then stream results and save each recipe to Firestore"
  pap5: "5. Images resolved from Paprika data or source page; single recipes use sequential API"

  pap1 -> pap2 -> pap3 -> pap4 -> pap5

  edit_flow: {
    label: "Recipe Edit Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  edit1: "1. User taps edit (pencil icon) on recipe detail screen"
  edit2: "2. EditRecipeScreen shows image picker, title/URL fields, optional AI instructions, and recipe body (markdown) as separate sections"
  edit3: "3. Image, title, and URL changes are saved directly without AI re-parsing"
  edit4: "4. Recipe body edits or non-empty AI instructions trigger AI cycle: RecipeEditWorker via EditRecipeUseCase (with existing density hints and user instructions)"
  edit5: "5. AI re-parses into structured recipe, preserving user's image (Save preserves ID/metadata; Save as Copy creates new recipe)"

  edit1 -> edit2 -> edit3 -> edit4 -> edit5

  share_flow: {
    label: "Recipe Sharing Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  share1: "Share as text: RecipeMarkdownFormatter creates Markdown, shared via ACTION_SEND text/plain"
  share2: "Share as file: ExportSingleRecipeUseCase creates .lorecipes ZIP, shared via FileProvider + ACTION_SEND"
  share3: "Import: .lorecipes file opened/shared to app opens ImportSelectionScreen (auto-imports single new recipes)"
  share4: "User selects recipes to import, ImportSelectionViewModel enqueues WorkManager job and navigates to RecipeList"

  share1 -> share2 -> share3 -> share4

  note: {
    label: "All imports run in background via WorkManager (URL, Paprika, .lorecipes). Import queue is database-backed (PendingImportEntity in Room) and persists across app restarts. Recipes and meal plans are stored in Firestore with unlimited persistent cache and fire-and-forget writes. Google Sign-In is required before accessing any data. Sign-out clears local Firestore cache. Paprika import uses the Message Batches API for multiple recipes (50% cheaper), submitting all recipes as a single batch for parallel processing, with fallback to sequential for single recipes. Batch cancellation propagates to the server. Export uses .lorecipes format (ZIP with RecipeSerializer) for both single recipe share and bulk backup."
    style: {
      font-size: 12
      italic: true
    }
  }

  favorites: {
    label: "Favorites Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  fav1: "Recipes can be starred/favorited from list or detail view"
  fav2: "Favorites are sorted first in the recipe list"
  fav3: "Re-sorting only occurs on filter/search/ID-set changes via runningFold"

  fav1 -> fav2 -> fav3

  meal_plan_flow: {
    label: "Meal Planner Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  mp1: "Weekly planner view with day-grouped meal entries"
  mp2: "Add meals via bottom sheet: recipe search + tag filter, date picker, meal type, servings"
  mp3: "Swipe-to-delete and long-press menu (shared pattern with recipe list)"
  mp4: "Persistent in Firestore (synced across devices)"
  mp5: "Included in ZIP export/import for backup/restore"

  mp1 -> mp2 -> mp3 -> mp4 -> mp5

  grocery_flow: {
    label: "Grocery List Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  gl1: "Shows only meals for the currently selected week (passed from meal planner via nav arg)"
  gl1a: "Select recipes from meal plan entries (grouped by date and meal type)"
  gl2: "Aggregate ingredients across recipes: deduplicate by normalized name, sum amounts in base units"
  gl3: "Display with check-off support: top-level hides all sub-items, sub-item reduces aggregate count"
  gl4: "Share as Markdown via Android share sheet"
  gl5: "Non-persistent: state resets between app sessions"

  gl1 -> gl1a -> gl2 -> gl3 -> gl4 -> gl5
}

# Testing Layer
testing: {
  label: Testing
  style: {
    fill: "#f5f5dc"
    stroke: "#999"
  }

  unit_tests: {
    label: Unit Tests
    shape: rectangle
    style: {
      fill: "#e8f5e9"
    }
  }

  ui_integration_tests: {
    label: UI Integration Tests\n(Robolectric + Compose)
    shape: rectangle
    style: {
      fill: "#e3f2fd"
    }
  }

  hilt_integration_tests: {
    label: Full-Stack Integration Tests\n(Hilt + Robolectric + Room)
    shape: rectangle
    tooltip: "HiltAndroidTest with real in-memory Room database, real DAOs, repositories, and use cases. External services (network, WorkManager, SettingsDataStore) are replaced with test doubles via @TestInstallIn and @BindValue. Tests: Recipe CRUD, Meal Plan + Grocery List, Data Consistency (JSON round-trip), Error Propagation."
    style: {
      fill: "#fce4ec"
    }
  }

  test_tags: {
    label: TestTags\n(ui.TestTags)
    shape: rectangle
    style: {
      fill: "#fff3e0"
    }
  }

  test_di: {
    label: Test DI Modules\n(TestDatabaseModule, TestNetworkModule, TestWorkerModule)
    shape: rectangle
    tooltip: "@TestInstallIn modules replacing production DI: in-memory Room database, Ktor MockEngine, WorkManager test helper."
    style: {
      fill: "#fff3e0"
    }
  }

  ui_integration_tests -> test_tags: uses
  hilt_integration_tests -> test_di: uses
}
