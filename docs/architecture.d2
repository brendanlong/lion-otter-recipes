# Lion+Otter Recipes - Architecture Diagram

direction: down

title: {
  label: Lion+Otter Recipes Architecture
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
  }
}

# External Services
external: {
  label: External Services
  style: {
    fill: "#f0f0f0"
    stroke: "#999"
  }

  anthropic: {
    label: Anthropic API
    shape: rectangle
    style: {
      fill: "#d4a03c"
    }
  }

  web: {
    label: Recipe Websites
    shape: rectangle
  }

  firebase: {
    label: Firebase (Firestore + Auth)
    shape: rectangle
    style: {
      fill: "#FFA000"
    }
  }
}

# Android App
app: {
  label: Android App
  style: {
    fill: "#e0f2f7"
    stroke: "#2a7b9b"
    stroke-width: 2
  }

  # UI Layer
  ui: {
    label: UI Layer (Compose)
    style: {
      fill: "#fff3e0"
      stroke: "#d4a03c"
    }

    screens: {
      label: Screens
      style: {
        fill: "#ffffff"
      }

      list: RecipeListScreen
      detail: {
        label: RecipeDetailScreen
        tooltip: "Displays recipe details with share menu (Markdown text or .lorecipes file), regenerate, and delete buttons. Regenerate re-parses from original HTML (or re-fetches from source URL if no cached HTML) with selectable model/thinking mode. All text is selectable."
      }
      add: AddRecipeScreen
      settings: SettingsScreen
      import_debug_list: {
        label: ImportDebugListScreen
        tooltip: "Lists all import debug entries with status, timestamp, and model info. Only accessible when import debugging is enabled."
      }
      import_debug_detail: {
        label: ImportDebugDetailScreen
        tooltip: "Tabbed detail view for a single import debug entry. Tabs: Summary (URL, lengths, tokens, model, cost, recipe link), Original Content (HTML with source toggle), Cleaned Content (HTML with source toggle), AI Output (JSON tree view with copy-to-clipboard button). All text is selectable."
      }

      meal_plan: {
        label: MealPlanScreen
        tooltip: "Weekly meal planner view. Shows meals grouped by day with swipe-to-delete, swipe-to-edit, and long-press menu (edit/delete). Recipe selector bottom sheet with search, tag filter, date picker, meal type selector, and servings. Supports edit mode to modify date, meal type, servings, and recipe of existing entries."
      }

      grocery_list: {
        label: GroceryListScreen
        tooltip: "Two-step grocery list generator. Step 1: Select recipes from meal plan entries (grouped by date/meal type, with select all/deselect all). Step 2: View aggregated ingredient list with deduplication across recipes, check-off support (top-level hides all, sub-item reduces count), and share as Markdown."
      }

      import_selection: {
        label: ImportSelectionScreen
        tooltip: "Shared recipe selection screen for all import types (Paprika, .lorecipes, ZIP backup). Shows checklist of recipes found in file, sorted alphabetically. Recipes checked by default unless already in app (by ID or name). Import button disabled when nothing selected. Select All / Deselect All buttons."
      }

      list -> detail: tap recipe
      list -> add: tap +
      list -> settings: tap gear
      list -> meal_plan: tap calendar
      meal_plan -> detail: tap recipe
      meal_plan -> grocery_list: tap cart icon
      add -> import_selection: pick Paprika file
      settings -> import_selection: pick ZIP file
      import_selection -> add: Paprika import selected
      add -> settings: no API key
      settings -> import_debug_list: view debug data
      import_debug_list -> import_debug_detail: tap entry
      import_debug_detail -> detail: view recipe
    }

    components: {
      label: Shared Components
      style: {
        fill: "#ffffff"
      }

      top_bar: RecipeTopAppBar
      error_card: ErrorCard
      progress_card: ProgressCard
      status_card: StatusCard
      delete_dialog: DeleteConfirmationDialog
      cancel_import_dialog: CancelImportConfirmationDialog
    }

    screens -> components: uses

    viewmodels: {
      label: ViewModels
      style: {
        fill: "#ffffff"
      }

      list_vm: RecipeListViewModel
      detail_vm: RecipeDetailViewModel
      add_vm: AddRecipeViewModel
      settings_vm: SettingsViewModel
      firebase_vm: {
        label: FirebaseSyncViewModel
        tooltip: "Manages Firebase sign-in state via Google Auth, sync enable/disable, and sync trigger via WorkManager"
      }
      zip_vm: {
        label: ZipExportImportViewModel
        tooltip: "Manages ZIP file export/import operations via WorkManager. Handles file picker integration and work status observation."
      }
      import_debug_list_vm: {
        label: ImportDebugListViewModel
        tooltip: "Observes all import debug entries from the repository as a StateFlow."
      }
      import_debug_detail_vm: {
        label: ImportDebugDetailViewModel
        tooltip: "Loads a single import debug entry by ID from SavedStateHandle."
      }
      file_import_vm: {
        label: FileImportViewModel
        tooltip: "Handles .lorecipes file imports. Reads ZIP file directly (single recipe, fast) and navigates to imported recipe."
      }
      meal_plan_vm: {
        label: MealPlanViewModel
        tooltip: "Manages weekly meal plan view state, add/edit dialog, and CRUD operations for meal plan entries. Supports editing existing entries (date, meal type, servings, recipe). Respects user's start-of-week setting from preferences. Triggers incremental Firebase sync on changes."
      }
      grocery_list_vm: {
        label: GroceryListViewModel
        tooltip: "Manages grocery list generation from meal plan. Two-step flow: recipe selection (from all meal plan entries) then aggregated ingredient display with check-off and share-as-Markdown support. Non-persistent state."
      }
      import_selection_vm: {
        label: ImportSelectionViewModel
        tooltip: "Shared ViewModel for import recipe selection. Parses import files (Paprika, .lorecipes, ZIP backup) to extract recipe names, checks for duplicates against existing recipes, and manages selection state. For Paprika: returns selected names for WorkManager import. For .lorecipes/ZIP: performs direct import of selected recipes."
      }
    }

    state: {
      label: UI State
      style: {
        fill: "#ffffff"
      }

      in_progress_mgr: {
        label: InProgressRecipeManager
        tooltip: "Database-backed import queue. Tracks recipes currently being imported via PendingImportEntity in Room. Observes WorkManager to update import status (metadata fetch, AI parsing, saving) and auto-clean completed entries. Supports canceling individual imports. Persists across app restarts."
      }
    }

    screens.list -> viewmodels.list_vm
    screens.detail -> viewmodels.detail_vm
    screens.add -> viewmodels.add_vm
    screens.settings -> viewmodels.settings_vm
    screens.settings -> viewmodels.firebase_vm: sign in/out
    screens.settings -> viewmodels.zip_vm: backup/restore
    screens.meal_plan -> viewmodels.meal_plan_vm
    screens.grocery_list -> viewmodels.grocery_list_vm
    screens.import_debug_list -> viewmodels.import_debug_list_vm
    screens.import_debug_detail -> viewmodels.import_debug_detail_vm
    screens.import_selection -> viewmodels.import_selection_vm
    viewmodels.list_vm -> state.in_progress_mgr: observes, cancel
    viewmodels.add_vm -> state.in_progress_mgr: adds entries
    state.in_progress_mgr -> background.worker: observes status
    state.in_progress_mgr -> data.repository.pending_import_repo: CRUD
  }

  # Background Processing Layer
  background: {
    label: Background Processing
    style: {
      fill: "#f3e5f5"
      stroke: "#9c27b0"
    }

    worker: {
      label: WorkManager
      style: {
        fill: "#ffffff"
      }

      base_worker: {
        label: BaseRecipeWorker
        tooltip: "Abstract base class providing shared foreground notification management and error/unavailable result handling for all recipe workers."
      }
      import_worker: {
        label: RecipeImportWorker
        tooltip: "CoroutineWorker that handles recipe import in background. Survives app closure and shows progress notifications. Supports queue of multiple imports."
      }
      regenerate_worker: {
        label: RecipeRegenerateWorker
        tooltip: "CoroutineWorker that re-parses a recipe from its stored original HTML using the AI. Supports selecting a different model and thinking mode. Overwrites the existing recipe, preserving ID, favorite status, and creation timestamp."
      }
      paprika_import_worker: {
        label: PaprikaImportWorker
        tooltip: "Imports recipes from a Paprika export file (.paprikarecipes). Parses ZIP of gzip-compressed JSON, sends content through AI pipeline."
      }
      sync_worker: {
        label: FirestoreSyncWorker
        tooltip: "Bidirectional sync with Firebase Firestore. Runs on app startup and periodically (every 6 hours). Uploads new local recipes, downloads new remote recipes, updates changed recipes using latest-timestamp-wins conflict resolution."
      }
      zip_export_worker: {
        label: ZipExportWorker
        tooltip: "Exports all recipes to a ZIP file using RecipeSerializer (recipe.json + original.html + recipe.md per recipe)."
      }
      zip_import_worker: {
        label: ZipImportWorker
        tooltip: "Imports recipes from a ZIP file. Reads recipe.json from each folder, skips duplicates, optionally restores original HTML."
      }
      import_worker -> base_worker: extends
      regenerate_worker -> base_worker: extends
      paprika_import_worker -> base_worker: extends
      sync_worker -> base_worker: extends
      zip_export_worker -> base_worker: extends
      zip_import_worker -> base_worker: extends
      work_ext: {
        label: "observeWorkByTag()"
        tooltip: "WorkManager extension function that encapsulates the common pattern of observing work by tag and filtering to a specific work ID. Used by AddRecipeViewModel, RecipeDetailViewModel (regenerate), FirebaseSyncViewModel (sync), and ZipExportImportViewModel."
      }
    }

    notification: {
      label: Notifications
      style: {
        fill: "#ffffff"
      }

      helper: {
        label: RecipeNotificationHelper
        tooltip: "Manages notification channel, foreground info for workers, and shows progress/success/error notifications for recipe imports, Firebase sync, and ZIP operations"
      }
    }

    worker.import_worker -> notification.helper: notify progress
    worker.regenerate_worker -> notification.helper: notify progress
    worker.paprika_import_worker -> notification.helper: notify progress
    worker.sync_worker -> notification.helper: notify progress
    worker.zip_export_worker -> notification.helper: notify progress
    worker.zip_import_worker -> notification.helper: notify progress
  }

  # Domain Layer
  domain: {
    label: Domain Layer
    style: {
      fill: "#e8f5e9"
      stroke: "#4caf50"
    }

    usecases: {
      label: Use Cases
      style: {
        fill: "#ffffff"
      }

      import: ImportRecipeUseCase
      parse_html: {
        label: ParseHtmlUseCase
        tooltip: "Central AI parsing use case. parseHtml() extracts content from HTML via Readability4J then delegates to parseText(). parseText() sends pre-extracted text to AI, builds Recipe, saves debug data. Used by URL import, Paprika import, and regeneration."
      }
      import_paprika: {
        label: ImportPaprikaUseCase
        tooltip: "Imports recipes from Paprika export (.paprikarecipes). Parses export, sends recipe content through ParseHtmlUseCase.parseText(), resolves images from Paprika data or source page. Supports cooperative cancellation â€” checks coroutine state between recipes and preserves already-imported recipes on cancel."
      }
      sync_firestore: {
        label: FirestoreSyncUseCase
        tooltip: "Bidirectional sync: compares local vs remote recipes, uploads new, downloads new, updates changed (latest timestamp wins), deletes remote recipes that were soft-deleted locally. Runs via WorkManager on startup and periodically."
      }
      export_zip: {
        label: ExportToZipUseCase
        tooltip: "Exports all recipes to a ZIP file using RecipeSerializer."
      }
      export_single: {
        label: ExportSingleRecipeUseCase
        tooltip: "Exports a single recipe to a .lorecipes file (ZIP format) for sharing. Uses RecipeSerializer for consistent format."
      }
      import_zip: {
        label: ImportFromZipUseCase
        tooltip: "Imports recipes from a ZIP file. Reads recipe.json from each folder, skips duplicates by ID, optionally restores original HTML."
      }
      regenerate: {
        label: RegenerateRecipeUseCase
        tooltip: "Re-parses a recipe from its stored original HTML via ParseHtmlUseCase.parseHtml(). If no cached HTML exists, fetches fresh HTML from the recipe's source URL via WebScraperService. Passes model/thinking overrides as parameters, preserves recipe ID, favorite status, and creation timestamp."
      }
      sync_meal_plans: {
        label: FirestoreMealPlanSyncUseCase
        tooltip: "Bidirectional sync of meal plans with Firebase Firestore. Each entry stored as a document. Handles soft-delete tracking, conflict resolution by timestamp, and purges deleted entries after sync."
      }
      aggregate_grocery: {
        label: AggregateGroceryListUseCase
        tooltip: "Aggregates ingredients from selected meal plan recipes into a deduplicated grocery list. Normalizes ingredient names by removing size prefixes (small/medium/large), sums amounts in base units across recipes."
      }
      tags: {
        label: GetTagsUseCase
        tooltip: "Selects top k tags using ILP optimization (ojalgo) to maximize coverage while penalizing generic tags. Falls back to greedy set cover if solver fails."
      }
      calc_usage: {
        label: CalculateIngredientUsageUseCase
        tooltip: "Pure domain logic for calculating ingredient usage status from checked instruction steps, scale, and measurement preference."
      }
    }

    util: {
      label: Utilities
      style: {
        fill: "#ffffff"
      }

      markdown: {
        label: RecipeMarkdownFormatter
        tooltip: "Converts Recipe to human-readable Markdown format for export"
      }
      serializer: {
        label: RecipeSerializer
        tooltip: "Shared logic for serializing/deserializing recipes in the standard folder export format (recipe.json + original.html + recipe.md). Used by ZIP export/import."
      }
      serializer -> markdown: format
    }

    models: {
      label: Domain Models
      style: {
        fill: "#ffffff"
      }

      recipe: {
        label: Recipe
        tooltip: "@Immutable. Fields: id, name, sourceUrl, story, servings, times, ingredients, instructions, equipment, tags, imageUrl, timestamps, isFavorite"
      }
      ingredient: {
        label: Ingredient
        tooltip: "@Immutable. Fields: name, notes, alternates, amounts, optional"
      }
      instruction: {
        label: InstructionStep
        tooltip: "@Immutable. Fields: stepNumber, instruction, ingredients, optional"
      }
      section: IngredientSection
      measurement: Measurement
      measurement_type: MeasurementType
      measurement_pref: MeasurementPreference
      unit_system: {
        label: UnitSystem
        tooltip: "Enum: METRIC, CUSTOMARY. Used for volume and weight unit preferences separately."
      }
      usage_status: {
        label: IngredientUsageStatus
        tooltip: "@Immutable. Fields: totalAmount, usedAmount, unit, isFullyUsed, remainingAmount"
      }
      meal_plan_entry: {
        label: MealPlanEntry
        tooltip: "@Immutable @Serializable. Fields: id, recipeId, recipeName, recipeImageUrl, date, mealType, servings, createdAt, updatedAt"
      }
      meal_type: {
        label: MealType
        tooltip: "Enum: BREAKFAST, LUNCH, SNACK, DINNER with displayOrder for sorting"
      }
      start_of_week: {
        label: StartOfWeek
        tooltip: "Enum: LOCALE_DEFAULT, MONDAY..SUNDAY. User preference for which day the week starts on in the meal planner. LOCALE_DEFAULT resolves to device locale's first day of week."
      }
      meal_plan_entry -> meal_type: type

      recipe -> section
      section -> ingredient
      ingredient -> ingredient: alternates
      ingredient -> measurement: amounts
      measurement -> measurement_type: type
      recipe -> instruction
      instruction -> ingredient: step ingredients
    }

    usecases.import -> usecases.parse_html: uses
    usecases.regenerate -> usecases.parse_html: uses
    usecases.parse_html -> data.repository.import_debug_repo: save debug data
    usecases.export_zip -> util.serializer: serialize
    usecases.export_single -> util.serializer: serialize
    usecases.import_zip -> util.serializer: deserialize
  }

  # Data Layer
  data: {
    label: Data Layer
    style: {
      fill: "#e3f2fd"
      stroke: "#2196f3"
    }

    repository: {
      label: Repository
      style: {
        fill: "#ffffff"
      }

      repo: {
        label: RecipeRepository
        tooltip: "CRUD operations for recipes. Supports soft-delete for sync tracking, hard-delete for sync cleanup, and purge of soft-deleted entries after sync."
      }
      import_debug_repo: {
        label: ImportDebugRepository
        tooltip: "CRUD operations for import debug entries. Supports listing all, getting by ID, saving, and deleting all entries."
      }
      pending_import_repo: {
        label: PendingImportRepository
        tooltip: "Database-backed import queue. CRUD operations for pending recipe imports. Tracks URL, page metadata (title, image), import status, and WorkManager job ID."
      }
      meal_plan_repo: {
        label: MealPlanRepository
        tooltip: "CRUD operations for meal plan entries. Supports date-range queries, soft-delete for sync tracking, and hard-delete for sync cleanup."
      }
    }

    local: {
      label: Local Storage
      style: {
        fill: "#ffffff"
      }

      room: {
        label: Room Database
        shape: cylinder
      }
      datastore: {
        label: DataStore
        shape: cylinder
      }
      encrypted_prefs: {
        label: EncryptedSharedPreferences
        shape: cylinder
        tooltip: "AES256-GCM encrypted storage for sensitive data like API keys"
        style: {
          fill: "#c8e6c9"
        }
      }
      dao: RecipeDao
      entity: {
        label: RecipeEntity
        tooltip: "Room entity for recipes: id, name, sourceUrl, story, servings, times, JSON fields, imageUrl, originalHtml, createdAt, updatedAt, isFavorite, deleted (soft-delete flag for sync)"
      }
      import_debug_dao: ImportDebugDao
      pending_import_dao: PendingImportDao
      pending_import_entity: {
        label: PendingImportEntity
        tooltip: "Room entity for the import queue: id, url, name, imageUrl, status, workManagerId, errorMessage, createdAt"
      }
      import_debug_entity: {
        label: ImportDebugEntity
        tooltip: "Room entity storing import debug data: source URL, original/cleaned HTML, AI output JSON, token counts, model, error info, linked recipe ID"
      }
      meal_plan_dao: MealPlanDao
      meal_plan_entity: {
        label: MealPlanEntity
        tooltip: "Room entity for meal plan entries: id, recipeId, recipeName, recipeImageUrl, date, mealType, servings, createdAt, updatedAt, deleted (soft-delete flag for sync)"
      }
      settings: {
        label: SettingsDataStore
        tooltip: "Uses EncryptedSharedPreferences for API key, DataStore for non-sensitive settings (AI model, extended thinking enabled, keep screen on, theme mode, volume/weight unit system preferences, grocery list volume/weight unit system preferences, start of week, import debugging enabled, Firebase sync enabled/last sync timestamp)"
      }

      dao -> room
      entity -> room
      import_debug_dao -> room
      import_debug_entity -> room
      pending_import_dao -> room
      pending_import_entity -> room
      meal_plan_dao -> room
      meal_plan_entity -> room
      settings -> datastore: non-sensitive settings
      settings -> encrypted_prefs: API key
    }

    remote: {
      label: Remote Services
      style: {
        fill: "#ffffff"
      }

      anthropic_svc: {
        label: AnthropicService
        tooltip: "Uses the Anthropic Java SDK (OkHttp) to parse recipes with volume/weight conversions, step-level ingredient extraction, and optional field detection. Extended thinking is configurable via settings. Supports Opus 4.6, Opus 4.5, Sonnet 4.5, and Haiku 4.5"
      }
      scraper: {
        label: WebScraperService
        tooltip: Uses Readability4J to extract article content
      }
      firestore_svc: {
        label: FirestoreService
        tooltip: "Handles Firebase Auth (Google Sign-In), and Firestore document operations for recipe and meal plan sync. Data stored at users/{userId}/recipes/{recipeId} and users/{userId}/mealPlans/{mealPlanId}."
      }
    }

    paprika: {
      label: Paprika
      style: {
        fill: "#ffffff"
      }

      parser: {
        label: PaprikaParser
        tooltip: "Parses Paprika export files (.paprikarecipes): ZIP of gzip-compressed JSON. Formats recipe content for AI parsing."
      }
      recipe_model: {
        label: PaprikaRecipe
        tooltip: "Data model for Paprika recipe JSON (name, ingredients, directions, notes, categories, photo_data, etc.)"
      }
    }

    repository.repo -> local.dao
    repository.repo -> local.settings
    repository.import_debug_repo -> local.import_debug_dao
    repository.pending_import_repo -> local.pending_import_dao
    repository.meal_plan_repo -> local.meal_plan_dao
  }

  # Performance
  performance: {
    label: Performance
    style: {
      fill: "#fff9c4"
      stroke: "#f9a825"
    }

    baseline_profile: {
      label: Baseline Profiles
      tooltip: "Pre-compiled critical code paths for faster startup and smoother scrolling. Generated via :baselineprofile macrobenchmark module."
    }

    profile_installer: {
      label: ProfileInstaller
      tooltip: "Installs Baseline Profiles at app install time for AOT compilation of critical paths."
    }

    baseline_profile -> profile_installer: generates rules for
  }

  # DI
  di: {
    label: Hilt DI
    style: {
      fill: "#fce4ec"
      stroke: "#e91e63"
    }

    app_module: AppModule
    db_module: DatabaseModule
    net_module: NetworkModule
    worker_module: WorkerModule
  }

  # Connections within app
  ui.viewmodels.list_vm -> data.repository.repo: recipes, delete
  ui.viewmodels.list_vm -> domain.usecases.tags: top tags
  ui.viewmodels.detail_vm -> data.repository.repo: recipe, delete, favorite
  ui.viewmodels.detail_vm -> domain.usecases.calc_usage: ingredient usage
  ui.viewmodels.detail_vm -> domain.usecases.export_single: export .lorecipes
  ui.viewmodels.detail_vm -> data.local.settings: keep screen on, unit prefs
  ui.viewmodels.detail_vm -> background.worker.regenerate_worker: regenerate
  ui.viewmodels.detail_vm -> background.worker.work_ext: observe regenerate
  ui.viewmodels.file_import_vm -> data.repository.repo: import recipe
  ui.viewmodels.file_import_vm -> domain.util.serializer: deserialize
  ui.viewmodels.import_selection_vm -> data.repository.repo: check duplicates, import
  ui.viewmodels.import_selection_vm -> domain.util.serializer: deserialize
  ui.viewmodels.import_selection_vm -> data.paprika.parser: parse export
  ui.viewmodels.add_vm -> background.worker: enqueue work
  ui.viewmodels.add_vm -> background.worker.work_ext: observe import
  ui.viewmodels.firebase_vm -> background.worker.sync_worker: sync
  ui.viewmodels.firebase_vm -> background.worker.work_ext: observe sync
  ui.viewmodels.firebase_vm -> data.local.settings: sync settings
  ui.viewmodels.zip_vm -> background.worker.zip_export_worker: export
  ui.viewmodels.zip_vm -> background.worker.zip_import_worker: import
  ui.viewmodels.zip_vm -> background.worker.work_ext: observe export/import
  ui.viewmodels.meal_plan_vm -> data.repository.meal_plan_repo: CRUD
  ui.viewmodels.meal_plan_vm -> data.repository.repo: recipe list
  ui.viewmodels.meal_plan_vm -> data.local.settings: start of week
  ui.viewmodels.meal_plan_vm -> domain.usecases.tags: top tags
  ui.viewmodels.grocery_list_vm -> data.repository.meal_plan_repo: meal plans
  ui.viewmodels.grocery_list_vm -> data.repository.repo: recipes
  ui.viewmodels.grocery_list_vm -> domain.usecases.aggregate_grocery: aggregate ingredients
  ui.viewmodels.grocery_list_vm -> data.local.settings: grocery unit prefs
  domain.usecases.sync_firestore -> domain.usecases.sync_meal_plans: sync meal plans
  domain.usecases.sync_meal_plans -> data.repository.meal_plan_repo: access data
  ui.viewmodels.settings_vm -> data.repository.import_debug_repo: delete debug data
  ui.viewmodels.import_debug_list_vm -> data.repository.import_debug_repo: list entries
  ui.viewmodels.import_debug_detail_vm -> data.repository.import_debug_repo: get entry
  background.worker.import_worker -> domain.usecases.import: execute
  background.worker.regenerate_worker -> domain.usecases.regenerate: execute
  background.worker.paprika_import_worker -> domain.usecases.import_paprika: execute
  background.worker.sync_worker -> domain.usecases.sync_firestore: execute
  background.worker.zip_export_worker -> domain.usecases.export_zip: execute
  background.worker.zip_import_worker -> domain.usecases.import_zip: execute
  domain.usecases -> data.repository: access data
  domain.usecases.import_paprika -> data.paprika.parser: parse export
  domain.usecases.import_paprika -> domain.usecases.parse_html: parseText
  domain.usecases.regenerate -> data.remote.scraper: fetch HTML if not cached
  domain.usecases.import_paprika -> data.remote.scraper: fetch source image
  data.remote.scraper -> external.web: fetch HTML
  data.remote.anthropic_svc -> external.anthropic: parse recipe
  data.remote.firestore_svc -> external.firebase: sync data
}

# Data Flow Legend
legend: {
  label: Data Flow
  near: bottom-center
  style: {
    fill: "#f5f5f5"
  }

  import_flow: {
    label: "URL Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  flow1: "1. User pastes URL and taps Import"
  flow2: "2. ViewModel enqueues WorkManager job"
  flow3: "3. RecipeImportWorker runs as foreground service"
  flow4: "4. Scraper fetches HTML, AI parses recipe"
  flow5: "5. Repository saves to Room"

  flow1 -> flow2 -> flow3 -> flow4 -> flow5

  firebase_flow: {
    label: "Firebase Sync Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  fb1: "User signs in with Google, enables sync"
  fb2: "Bidirectional sync on startup + every 6 hours (latest timestamp wins)"
  fb3: "Uploads new local recipes, downloads new remote recipes, updates changed, deletes soft-deleted from Firestore"

  fb1 -> fb2 -> fb3

  zip_flow: {
    label: "ZIP Export/Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  zip1: "Export: User picks save location, ZipExportWorker writes ZIP"
  zip2: "Import: User picks .zip file, selects recipes via ImportSelectionScreen, imports selected"
  zip3: "Uses RecipeSerializer for consistent format"
  zip4: "Skips recipes that already exist locally (by ID)"

  zip1 -> zip2 -> zip3 -> zip4

  paprika_flow: {
    label: "Paprika Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  pap1: "1. User picks .paprikarecipes file, selects recipes to import"
  pap2: "2. PaprikaImportWorker parses ZIP of gzip-compressed JSON (filtered to selected)"
  pap3: "3. Each recipe's content (not source URL) sent to AI"
  pap4: "4. Image resolved from Paprika data or source page"
  pap5: "5. Repository saves each parsed recipe to Room"

  pap1 -> pap2 -> pap3 -> pap4 -> pap5

  share_flow: {
    label: "Recipe Sharing Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  share1: "Share as text: RecipeMarkdownFormatter creates Markdown, shared via ACTION_SEND text/plain"
  share2: "Share as file: ExportSingleRecipeUseCase creates .lorecipes ZIP, shared via FileProvider + ACTION_SEND"
  share3: "Import: .lorecipes file opened/shared to app opens ImportSelectionScreen"
  share4: "User selects recipes to import, ImportSelectionViewModel imports selected and navigates to recipe"

  share1 -> share2 -> share3 -> share4

  note: {
    label: "Import runs in background via WorkManager. Import queue is database-backed (PendingImportEntity) and persists across app restarts. Supports multiple concurrent imports with individual cancellation from the recipe list via swipe-to-dismiss. Page metadata (title, image) is fetched cheaply before AI parsing begins. Firebase sync, ZIP export/import, and Paprika import run in background with progress notifications. Sync runs on app startup and every 6 hours when enabled. Paprika import can be cancelled mid-way, keeping already-imported recipes. ZIP export uses RecipeSerializer for consistent format."
    style: {
      font-size: 12
      italic: true
    }
  }

  favorites: {
    label: "Favorites Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  fav1: "Recipes can be starred/favorited from list or detail view"
  fav2: "Favorites are sorted first in the recipe list"
  fav3: "Re-sorting only occurs on filter/search/ID-set changes via runningFold"

  fav1 -> fav2 -> fav3

  meal_plan_flow: {
    label: "Meal Planner Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  mp1: "Weekly planner view with day-grouped meal entries"
  mp2: "Add meals via bottom sheet: recipe search + tag filter, date picker, meal type, servings"
  mp3: "Swipe-to-delete and long-press menu (shared pattern with recipe list)"
  mp4: "Persistent in Room DB with soft-delete for sync tracking"
  mp5: "Firebase Firestore sync: each entry stored as a document"
  mp6: "Included in ZIP export/import for backup/restore"
  mp7: "Incremental sync triggered on add/update/delete"

  mp1 -> mp2 -> mp3 -> mp4 -> mp5 -> mp6 -> mp7

  grocery_flow: {
    label: "Grocery List Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  gl1: "Shows only meals for the currently selected week (passed from meal planner via nav arg)"
  gl1a: "Select recipes from meal plan entries (grouped by date and meal type)"
  gl2: "Aggregate ingredients across recipes: deduplicate by normalized name, sum amounts in base units"
  gl3: "Display with check-off support: top-level hides all sub-items, sub-item reduces aggregate count"
  gl4: "Share as Markdown via Android share sheet"
  gl5: "Non-persistent: state resets between app sessions"

  gl1 -> gl1a -> gl2 -> gl3 -> gl4 -> gl5
}
