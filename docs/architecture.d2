# Lion+Otter Recipes - Architecture Diagram

direction: down

title: {
  label: Lion+Otter Recipes Architecture
  near: top-center
  shape: text
  style: {
    font-size: 24
    bold: true
  }
}

# External Services
external: {
  label: External Services
  style: {
    fill: "#f0f0f0"
    stroke: "#999"
  }

  anthropic: {
    label: Anthropic API
    shape: rectangle
    style: {
      fill: "#d4a03c"
    }
  }

  web: {
    label: Recipe Websites
    shape: rectangle
  }

}

# Android App
app: {
  label: Android App
  style: {
    fill: "#e0f2f7"
    stroke: "#2a7b9b"
    stroke-width: 2
  }

  # UI Layer
  ui: {
    label: UI Layer (Compose)
    style: {
      fill: "#fff3e0"
      stroke: "#d4a03c"
    }

    screens: {
      label: Screens
      style: {
        fill: "#ffffff"
      }

      list: RecipeListScreen
      detail: {
        label: RecipeDetailScreen
        tooltip: "Displays recipe details with share menu (Markdown text or .lorecipes file), regenerate, and delete buttons. Regenerate re-parses from original HTML (or re-fetches from source URL if no cached HTML) with selectable model/thinking mode. All text is selectable."
      }
      add: AddRecipeScreen
      settings: SettingsScreen
      import_debug_list: {
        label: ImportDebugListScreen
        tooltip: "Lists all import debug entries with status, timestamp, and model info. Only accessible when import debugging is enabled."
      }
      import_debug_detail: {
        label: ImportDebugDetailScreen
        tooltip: "Tabbed detail view for a single import debug entry. Tabs: Summary (URL, lengths, tokens, model, cost, recipe link), Original Content (HTML with source toggle), Cleaned Content (HTML with source toggle), AI Output (JSON tree view with copy-to-clipboard button). All text is selectable."
      }

      meal_plan: {
        label: MealPlanScreen
        tooltip: "Weekly meal planner view. Shows meals grouped by day with swipe-to-delete, swipe-to-edit, and long-press menu (edit/delete). Recipe selector bottom sheet with search, tag filter, date picker, meal type selector, and servings. Supports edit mode to modify date, meal type, servings, and recipe of existing entries."
      }

      grocery_list: {
        label: GroceryListScreen
        tooltip: "Two-step grocery list generator. Step 1: Select recipes from meal plan entries (grouped by date/meal type, with select all/deselect all). Step 2: View aggregated ingredient list with deduplication across recipes, check-off support (top-level hides all, sub-item reduces count), and share as Markdown."
      }

      import_selection: {
        label: ImportSelectionScreen
        tooltip: "Shared recipe selection screen for all import types (Paprika, .lorecipes). Shows checklist of recipes found in file, sorted alphabetically. Recipes checked by default unless already in app (by ID or name). Import button disabled when nothing selected. Select All / Deselect All buttons. Single new .lorecipes recipes are auto-imported without showing selection."
      }

      list -> detail: tap recipe
      list -> add: tap +
      list -> settings: tap gear
      list -> meal_plan: tap calendar
      meal_plan -> detail: tap recipe
      meal_plan -> grocery_list: tap cart icon
      add -> import_selection: pick file (.lorecipes / .paprikarecipes)
      settings -> import_selection: pick file (.lorecipes / .paprikarecipes)
      import_selection -> list: import started
      add -> settings: no API key
      settings -> import_debug_list: view debug data
      import_debug_list -> import_debug_detail: tap entry
      import_debug_detail -> detail: view recipe
    }

    components: {
      label: Shared Components
      style: {
        fill: "#ffffff"
      }

      top_bar: RecipeTopAppBar
      error_card: ErrorCard
      progress_card: ProgressCard
      status_card: StatusCard
      delete_dialog: DeleteConfirmationDialog
      cancel_import_dialog: CancelImportConfirmationDialog
    }

    screens -> components: uses

    viewmodels: {
      label: ViewModels
      style: {
        fill: "#ffffff"
      }

      list_vm: RecipeListViewModel
      detail_vm: RecipeDetailViewModel
      add_vm: AddRecipeViewModel
      settings_vm: SettingsViewModel
      zip_vm: {
        label: ZipExportImportViewModel
        tooltip: "Manages .lorecipes file export operations via WorkManager. Import is handled by ImportSelectionViewModel."
      }
      import_debug_list_vm: {
        label: ImportDebugListViewModel
        tooltip: "Observes all import debug entries from the repository as a StateFlow."
      }
      import_debug_detail_vm: {
        label: ImportDebugDetailViewModel
        tooltip: "Loads a single import debug entry by ID from SavedStateHandle."
      }
      meal_plan_vm: {
        label: MealPlanViewModel
        tooltip: "Manages weekly meal plan view state, add/edit dialog, and CRUD operations for meal plan entries. Supports editing existing entries (date, meal type, servings, recipe). Respects user's start-of-week setting from preferences."
      }
      grocery_list_vm: {
        label: GroceryListViewModel
        tooltip: "Manages grocery list generation from meal plan. Two-step flow: recipe selection (from all meal plan entries) then aggregated ingredient display with check-off and share-as-Markdown support. Non-persistent state."
      }
      import_selection_vm: {
        label: ImportSelectionViewModel
        tooltip: "Shared ViewModel for import recipe selection. Parses import files (Paprika, .lorecipes) to extract recipe names, checks for duplicates against existing recipes, and manages selection state. Enqueues WorkManager jobs for all import types and registers in-progress entries via InProgressRecipeManager."
      }
    }

    state: {
      label: UI State
      style: {
        fill: "#ffffff"
      }

      in_progress_mgr: {
        label: InProgressRecipeManager
        tooltip: "Database-backed import queue. Tracks recipes currently being imported via PendingImportEntity in Room. Observes WorkManager to update import status (metadata fetch, AI parsing, saving) and auto-clean completed entries. Supports canceling individual imports. Persists across app restarts."
      }
    }

    screens.list -> viewmodels.list_vm
    screens.detail -> viewmodels.detail_vm
    screens.add -> viewmodels.add_vm
    screens.settings -> viewmodels.settings_vm
    screens.settings -> viewmodels.zip_vm: backup/restore
    screens.meal_plan -> viewmodels.meal_plan_vm
    screens.grocery_list -> viewmodels.grocery_list_vm
    screens.import_debug_list -> viewmodels.import_debug_list_vm
    screens.import_debug_detail -> viewmodels.import_debug_detail_vm
    screens.import_selection -> viewmodels.import_selection_vm
    viewmodels.list_vm -> state.in_progress_mgr: observes, cancel
    viewmodels.add_vm -> state.in_progress_mgr: adds entries
    state.in_progress_mgr -> background.worker: observes status
    state.in_progress_mgr -> data.repository.pending_import_repo: CRUD
  }

  # Background Processing Layer
  background: {
    label: Background Processing
    style: {
      fill: "#f3e5f5"
      stroke: "#9c27b0"
    }

    worker: {
      label: WorkManager
      style: {
        fill: "#ffffff"
      }

      base_worker: {
        label: BaseRecipeWorker
        tooltip: "Abstract base class providing shared foreground notification management and error/unavailable result handling for all recipe workers."
      }
      import_worker: {
        label: RecipeImportWorker
        tooltip: "CoroutineWorker that handles recipe import in background. Survives app closure and shows progress notifications. Supports queue of multiple imports."
      }
      regenerate_worker: {
        label: RecipeRegenerateWorker
        tooltip: "CoroutineWorker that re-parses a recipe from its stored original HTML using the AI. Supports selecting a different model and thinking mode. Overwrites the existing recipe, preserving ID, favorite status, and creation timestamp."
      }
      paprika_import_worker: {
        label: PaprikaImportWorker
        tooltip: "Imports recipes from a Paprika export file (.paprikarecipes). Parses ZIP of gzip-compressed JSON, sends content through AI pipeline."
      }
      zip_export_worker: {
        label: ZipExportWorker
        tooltip: "Exports all recipes to a ZIP file using RecipeSerializer (recipe.json + original.html + recipe.md per recipe)."
      }
      zip_import_worker: {
        label: ZipImportWorker
        tooltip: "Imports recipes from a ZIP file. Reads recipe.json from each folder, skips duplicates, optionally restores original HTML."
      }
      import_worker -> base_worker: extends
      regenerate_worker -> base_worker: extends
      paprika_import_worker -> base_worker: extends
      zip_export_worker -> base_worker: extends
      zip_import_worker -> base_worker: extends
      work_ext: {
        label: "observeWorkByTag()"
        tooltip: "WorkManager extension function that encapsulates the common pattern of observing work by tag and filtering to a specific work ID. Used by AddRecipeViewModel, RecipeDetailViewModel (regenerate), and ZipExportImportViewModel."
      }
    }

    notification: {
      label: Notifications
      style: {
        fill: "#ffffff"
      }

      helper: {
        label: RecipeNotificationHelper
        tooltip: "Manages notification channel, foreground info for workers, and shows progress/success/error notifications for recipe imports and ZIP operations"
      }
    }

    worker.import_worker -> notification.helper: notify progress
    worker.regenerate_worker -> notification.helper: notify progress
    worker.paprika_import_worker -> notification.helper: notify progress
    worker.zip_export_worker -> notification.helper: notify progress
    worker.zip_import_worker -> notification.helper: notify progress
  }

  # Domain Layer
  domain: {
    label: Domain Layer
    style: {
      fill: "#e8f5e9"
      stroke: "#4caf50"
    }

    usecases: {
      label: Use Cases
      style: {
        fill: "#ffffff"
      }

      import: ImportRecipeUseCase
      parse_html: {
        label: ParseHtmlUseCase
        tooltip: "Central AI parsing use case. parseHtml() extracts content from HTML via Readability4J then delegates to parseText(). parseText() sends pre-extracted text to AI, builds Recipe, saves debug data. Used by URL import, Paprika import, and regeneration."
      }
      import_paprika: {
        label: ImportPaprikaUseCase
        tooltip: "Imports recipes from Paprika export (.paprikarecipes). Parses export, sends recipe content through ParseHtmlUseCase.parseText(). Resolves images by priority: base64 photo_data (saved directly to local storage), image_url, or og:image from source page. Supports cooperative cancellation â€” checks coroutine state between recipes and preserves already-imported recipes on cancel."
      }
      export_zip: {
        label: ExportToZipUseCase
        tooltip: "Exports all recipes to a ZIP file using RecipeSerializer. Includes recipe images as binary files in each recipe folder."
      }
      export_single: {
        label: ExportSingleRecipeUseCase
        tooltip: "Exports a single recipe to a .lorecipes file (ZIP format) for sharing. Uses RecipeSerializer for consistent format. Includes recipe image if available."
      }
      import_zip: {
        label: ImportFromZipUseCase
        tooltip: "Imports recipes from a ZIP file. Reads recipe.json from each folder, skips duplicates by ID, optionally restores original HTML."
      }
      regenerate: {
        label: RegenerateRecipeUseCase
        tooltip: "Re-parses a recipe from its stored original HTML via ParseHtmlUseCase.parseHtml(). If no cached HTML exists, fetches fresh HTML from the recipe's source URL via WebScraperService. Passes model/thinking overrides as parameters, preserves recipe ID, favorite status, and creation timestamp."
      }
      aggregate_grocery: {
        label: AggregateGroceryListUseCase
        tooltip: "Aggregates ingredients from selected meal plan recipes into a deduplicated grocery list. Normalizes ingredient names by removing size prefixes (small/medium/large), sums amounts in base units across recipes."
      }
      tags: {
        label: GetTagsUseCase
        tooltip: "Selects top k tags using ILP optimization (ojalgo) to maximize coverage while penalizing generic tags. Falls back to greedy set cover if solver fails."
      }
      calc_usage: {
        label: CalculateIngredientUsageUseCase
        tooltip: "Pure domain logic for calculating ingredient usage status from checked instruction steps, scale, and measurement preference."
      }
    }

    util: {
      label: Utilities
      style: {
        fill: "#ffffff"
      }

      markdown: {
        label: RecipeMarkdownFormatter
        tooltip: "Converts Recipe to human-readable Markdown format for export"
      }
      serializer: {
        label: RecipeSerializer
        tooltip: "Shared logic for serializing/deserializing recipes in the standard folder export format (recipe.json + original.html + recipe.md + image.*). Used by ZIP export/import."
      }
      zip_import_helper: {
        label: ZipImportHelper
        tooltip: "Shared helper for importing recipes and meal plans from ZIP files. Consolidates ZIP reading (text + image files), recipe import (deserialize, deduplicate, import bundled image or download, save), and meal plan import logic. Used by ImportFromZipUseCase and ImportSelectionViewModel."
      }
      serializer -> markdown: format
      zip_import_helper -> serializer: deserialize
    }

    models: {
      label: Domain Models
      style: {
        fill: "#ffffff"
      }

      recipe: {
        label: Recipe
        tooltip: "@Immutable. Fields: id, name, sourceUrl, story, servings, times, ingredients, instructions, equipment, tags, imageUrl (local file:// URI), sourceImageUrl (original remote URL), timestamps, isFavorite"
      }
      ingredient: {
        label: Ingredient
        tooltip: "@Immutable. Fields: name, notes, alternates, amounts, optional"
      }
      instruction: {
        label: InstructionStep
        tooltip: "@Immutable. Fields: stepNumber, instruction, ingredients, optional"
      }
      section: IngredientSection
      measurement: Measurement
      measurement_type: MeasurementType
      measurement_pref: MeasurementPreference
      unit_system: {
        label: UnitSystem
        tooltip: "Enum: METRIC, CUSTOMARY. Used for volume and weight unit preferences separately."
      }
      usage_status: {
        label: IngredientUsageStatus
        tooltip: "@Immutable. Fields: totalAmount, usedAmount, unit, isFullyUsed, remainingAmount"
      }
      meal_plan_entry: {
        label: MealPlanEntry
        tooltip: "@Immutable @Serializable. Fields: id, recipeId, recipeName, recipeImageUrl, date, mealType, servings, createdAt, updatedAt"
      }
      meal_type: {
        label: MealType
        tooltip: "Enum: BREAKFAST, LUNCH, SNACK, DINNER with displayOrder for sorting"
      }
      start_of_week: {
        label: StartOfWeek
        tooltip: "Enum: LOCALE_DEFAULT, MONDAY..SUNDAY. User preference for which day the week starts on in the meal planner. LOCALE_DEFAULT resolves to device locale's first day of week."
      }
      meal_plan_entry -> meal_type: type

      recipe -> section
      section -> ingredient
      ingredient -> ingredient: alternates
      ingredient -> measurement: amounts
      measurement -> measurement_type: type
      recipe -> instruction
      instruction -> ingredient: step ingredients
    }

    usecases.import -> usecases.parse_html: uses
    usecases.regenerate -> usecases.parse_html: uses
    usecases.parse_html -> data.repository.import_debug_repo: save debug data
    usecases.export_zip -> util.serializer: serialize
    usecases.export_zip -> data.remote.image_dl: read local images
    usecases.export_single -> util.serializer: serialize
    usecases.export_single -> data.remote.image_dl: read local images
    usecases.import_paprika -> data.remote.image_dl: save base64 images
    usecases.import_zip -> util.zip_import_helper: import
  }

  # Data Layer
  data: {
    label: Data Layer
    style: {
      fill: "#e3f2fd"
      stroke: "#2196f3"
    }

    repository: {
      label: Repository
      style: {
        fill: "#ffffff"
      }

      repo: {
        label: RecipeRepository
        tooltip: "CRUD operations for recipes."
      }
      import_debug_repo: {
        label: ImportDebugRepository
        tooltip: "CRUD operations for import debug entries. Supports listing all, getting by ID, saving, and deleting all entries."
      }
      pending_import_repo: {
        label: PendingImportRepository
        tooltip: "Database-backed import queue. CRUD operations for pending recipe imports. Tracks URL, page metadata (title, image), import status, and WorkManager job ID."
      }
      meal_plan_repo: {
        label: MealPlanRepository
        tooltip: "CRUD operations for meal plan entries. Supports date-range queries."
      }
    }

    local: {
      label: Local Storage
      style: {
        fill: "#ffffff"
      }

      room: {
        label: Room Database
        shape: cylinder
      }
      datastore: {
        label: DataStore
        shape: cylinder
      }
      encrypted_prefs: {
        label: EncryptedSharedPreferences
        shape: cylinder
        tooltip: "AES256-GCM encrypted storage for sensitive data like API keys"
        style: {
          fill: "#c8e6c9"
        }
      }
      dao: RecipeDao
      entity: {
        label: RecipeEntity
        tooltip: "Room entity for recipes: id, name, sourceUrl, story, servings, times, JSON fields, imageUrl (local file:// URI), originalHtml, createdAt, updatedAt, isFavorite"
      }
      import_debug_dao: ImportDebugDao
      pending_import_dao: PendingImportDao
      pending_import_entity: {
        label: PendingImportEntity
        tooltip: "Room entity for the import queue: id, url, name, imageUrl, status, workManagerId, errorMessage, createdAt"
      }
      import_debug_entity: {
        label: ImportDebugEntity
        tooltip: "Room entity storing import debug data: source URL, original/cleaned HTML, AI output JSON, token counts, model, error info, linked recipe ID"
      }
      meal_plan_dao: MealPlanDao
      meal_plan_entity: {
        label: MealPlanEntity
        tooltip: "Room entity for meal plan entries: id, recipeId, recipeName, recipeImageUrl, date, mealType, servings, createdAt, updatedAt"
      }
      image_storage: {
        label: Local Image Storage
        shape: cylinder
        tooltip: "Recipe images stored as files in app internal storage (filesDir/recipe_images/). Referenced by file:// URIs in Recipe.imageUrl."
      }
      settings: {
        label: SettingsDataStore
        tooltip: "Uses EncryptedSharedPreferences for API key, DataStore for non-sensitive settings (AI model, extended thinking enabled, keep screen on, theme mode, volume/weight unit system preferences, grocery list volume/weight unit system preferences, start of week, import debugging enabled)"
      }

      dao -> room
      entity -> room
      import_debug_dao -> room
      import_debug_entity -> room
      pending_import_dao -> room
      pending_import_entity -> room
      meal_plan_dao -> room
      meal_plan_entity -> room
      settings -> datastore: non-sensitive settings
      settings -> encrypted_prefs: API key
    }

    remote: {
      label: Remote Services
      style: {
        fill: "#ffffff"
      }

      anthropic_svc: {
        label: AnthropicService
        tooltip: "Uses the Anthropic Java SDK (OkHttp) to parse recipes with volume/weight conversions, step-level ingredient extraction, and optional field detection. Extended thinking is configurable via settings. Supports Opus 4.6, Opus 4.5, Sonnet 4.5, and Haiku 4.5"
      }
      scraper: {
        label: WebScraperService
        tooltip: Uses Readability4J to extract article content
      }
      image_dl: {
        label: ImageDownloadService
        tooltip: "Downloads recipe images from remote URLs and stores them locally in app internal storage. Automatically retries with HTTPS if an HTTP download fails (e.g., cleartext traffic not permitted). Also supports saving images from byte streams (ZIP import) and base64 data (Paprika photo_data). Returns file:// URIs for local access. Used during import, export, and ZIP restore to ensure images are available offline."
      }
    }

    paprika: {
      label: Paprika
      style: {
        fill: "#ffffff"
      }

      parser: {
        label: PaprikaParser
        tooltip: "Parses Paprika export files (.paprikarecipes): ZIP of gzip-compressed JSON. Formats recipe content for AI parsing."
      }
      recipe_model: {
        label: PaprikaRecipe
        tooltip: "Data model for Paprika recipe JSON (name, ingredients, directions, notes, categories, photo_data, etc.)"
      }
    }

    repository.repo -> local.dao
    repository.repo -> local.settings
    repository.import_debug_repo -> local.import_debug_dao
    repository.pending_import_repo -> local.pending_import_dao
    repository.meal_plan_repo -> local.meal_plan_dao
    remote.image_dl -> local.image_storage: stores images
  }

  # Performance
  performance: {
    label: Performance
    style: {
      fill: "#fff9c4"
      stroke: "#f9a825"
    }

    baseline_profile: {
      label: Baseline Profiles
      tooltip: "Pre-compiled critical code paths for faster startup and smoother scrolling. Generated via :baselineprofile macrobenchmark module."
    }

    profile_installer: {
      label: ProfileInstaller
      tooltip: "Installs Baseline Profiles at app install time for AOT compilation of critical paths."
    }

    baseline_profile -> profile_installer: generates rules for
  }

  # DI
  di: {
    label: Hilt DI
    style: {
      fill: "#fce4ec"
      stroke: "#e91e63"
    }

    app_module: AppModule
    db_module: DatabaseModule
    net_module: NetworkModule
    worker_module: WorkerModule
  }

  # Connections within app
  ui.viewmodels.list_vm -> data.repository.repo: recipes, delete
  ui.viewmodels.list_vm -> data.repository.meal_plan_repo: cascade delete meal plans
  ui.viewmodels.list_vm -> domain.usecases.tags: top tags
  ui.viewmodels.detail_vm -> data.repository.repo: recipe, delete, favorite
  ui.viewmodels.detail_vm -> data.repository.meal_plan_repo: cascade delete meal plans
  ui.viewmodels.detail_vm -> domain.usecases.calc_usage: ingredient usage
  ui.viewmodels.detail_vm -> domain.usecases.export_single: export .lorecipes
  ui.viewmodels.detail_vm -> data.local.settings: keep screen on, unit prefs
  ui.viewmodels.detail_vm -> background.worker.regenerate_worker: regenerate
  ui.viewmodels.detail_vm -> background.worker.work_ext: observe regenerate
  ui.viewmodels.import_selection_vm -> data.repository.repo: check duplicates
  ui.viewmodels.import_selection_vm -> domain.util.serializer: deserialize (for selection preview)
  ui.viewmodels.import_selection_vm -> domain.util.zip_import_helper: read ZIP contents
  ui.viewmodels.import_selection_vm -> data.paprika.parser: parse export
  ui.viewmodels.import_selection_vm -> background.worker: enqueue work
  ui.viewmodels.import_selection_vm -> state.in_progress_mgr: adds entries
  ui.viewmodels.add_vm -> background.worker: enqueue work
  ui.viewmodels.add_vm -> background.worker.work_ext: observe import
  ui.viewmodels.zip_vm -> background.worker.zip_export_worker: export
  ui.viewmodels.zip_vm -> background.worker.work_ext: observe export
  ui.viewmodels.meal_plan_vm -> data.repository.meal_plan_repo: CRUD
  ui.viewmodels.meal_plan_vm -> data.repository.repo: recipe list
  ui.viewmodels.meal_plan_vm -> data.local.settings: start of week
  ui.viewmodels.meal_plan_vm -> domain.usecases.tags: top tags
  ui.viewmodels.grocery_list_vm -> data.repository.meal_plan_repo: meal plans
  ui.viewmodels.grocery_list_vm -> data.repository.repo: recipes
  ui.viewmodels.grocery_list_vm -> domain.usecases.aggregate_grocery: aggregate ingredients
  ui.viewmodels.grocery_list_vm -> data.local.settings: grocery unit prefs
  ui.viewmodels.settings_vm -> data.repository.import_debug_repo: delete debug data
  ui.viewmodels.import_debug_list_vm -> data.repository.import_debug_repo: list entries
  ui.viewmodels.import_debug_detail_vm -> data.repository.import_debug_repo: get entry
  background.worker.import_worker -> domain.usecases.import: execute
  background.worker.regenerate_worker -> domain.usecases.regenerate: execute
  background.worker.paprika_import_worker -> domain.usecases.import_paprika: execute
  background.worker.zip_export_worker -> domain.usecases.export_zip: execute
  background.worker.zip_import_worker -> domain.usecases.import_zip: execute
  domain.usecases -> data.repository: access data
  domain.util.zip_import_helper -> data.repository.repo: save recipe, check duplicates
  domain.util.zip_import_helper -> data.repository.meal_plan_repo: import meal plans
  domain.util.zip_import_helper -> data.remote.image_dl: download image
  domain.usecases.import_paprika -> data.paprika.parser: parse export
  domain.usecases.import_paprika -> domain.usecases.parse_html: parseText
  domain.usecases.regenerate -> data.remote.scraper: fetch HTML if not cached
  domain.usecases.import_paprika -> data.remote.scraper: fetch source image
  domain.usecases.parse_html -> data.remote.image_dl: download image
  data.remote.scraper -> external.web: fetch HTML
  data.remote.image_dl -> external.web: download image
  data.remote.anthropic_svc -> external.anthropic: parse recipe
}

# Data Flow Legend
legend: {
  label: Data Flow
  near: bottom-center
  style: {
    fill: "#f5f5f5"
  }

  import_flow: {
    label: "URL Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  flow1: "1. User pastes URL and taps Import"
  flow2: "2. ViewModel enqueues WorkManager job"
  flow3: "3. RecipeImportWorker runs as foreground service"
  flow4: "4. Scraper fetches HTML, AI parses recipe"
  flow5: "5. Repository saves to Room"

  flow1 -> flow2 -> flow3 -> flow4 -> flow5

  zip_flow: {
    label: ".lorecipes Export/Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  zip1: "Export: User picks save location, ZipExportWorker writes .lorecipes file"
  zip2: "Import: User picks .lorecipes file, selects recipes via ImportSelectionScreen"
  zip3: "ZipImportWorker imports selected recipes in background via WorkManager"
  zip4: "Uses RecipeSerializer for consistent format, skips duplicates by ID"

  zip1 -> zip2 -> zip3 -> zip4

  paprika_flow: {
    label: "Paprika Import Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  pap1: "1. User picks .paprikarecipes file, selects recipes to import"
  pap2: "2. PaprikaImportWorker parses ZIP of gzip-compressed JSON (filtered to selected)"
  pap3: "3. Each recipe's content (not source URL) sent to AI"
  pap4: "4. Image resolved from Paprika data or source page"
  pap5: "5. Repository saves each parsed recipe to Room"

  pap1 -> pap2 -> pap3 -> pap4 -> pap5

  share_flow: {
    label: "Recipe Sharing Flow"
    style: {
      font-size: 14
      bold: true
    }
  }
  share1: "Share as text: RecipeMarkdownFormatter creates Markdown, shared via ACTION_SEND text/plain"
  share2: "Share as file: ExportSingleRecipeUseCase creates .lorecipes ZIP, shared via FileProvider + ACTION_SEND"
  share3: "Import: .lorecipes file opened/shared to app opens ImportSelectionScreen (auto-imports single new recipes)"
  share4: "User selects recipes to import, ImportSelectionViewModel enqueues WorkManager job and navigates to RecipeList"

  share1 -> share2 -> share3 -> share4

  note: {
    label: "All imports run in background via WorkManager (URL, Paprika, .lorecipes). Import queue is database-backed (PendingImportEntity) and persists across app restarts. Supports multiple concurrent imports with individual cancellation from the recipe list via swipe-to-dismiss. Page metadata (title, image) is fetched cheaply before AI parsing begins. Paprika import runs in background with progress notifications and can be cancelled mid-way, keeping already-imported recipes. Export uses .lorecipes format (ZIP with RecipeSerializer) for both single recipe share and bulk backup."
    style: {
      font-size: 12
      italic: true
    }
  }

  favorites: {
    label: "Favorites Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  fav1: "Recipes can be starred/favorited from list or detail view"
  fav2: "Favorites are sorted first in the recipe list"
  fav3: "Re-sorting only occurs on filter/search/ID-set changes via runningFold"

  fav1 -> fav2 -> fav3

  meal_plan_flow: {
    label: "Meal Planner Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  mp1: "Weekly planner view with day-grouped meal entries"
  mp2: "Add meals via bottom sheet: recipe search + tag filter, date picker, meal type, servings"
  mp3: "Swipe-to-delete and long-press menu (shared pattern with recipe list)"
  mp4: "Persistent in Room DB"
  mp5: "Included in ZIP export/import for backup/restore"

  mp1 -> mp2 -> mp3 -> mp4 -> mp5

  grocery_flow: {
    label: "Grocery List Feature"
    style: {
      font-size: 14
      bold: true
    }
  }
  gl1: "Shows only meals for the currently selected week (passed from meal planner via nav arg)"
  gl1a: "Select recipes from meal plan entries (grouped by date and meal type)"
  gl2: "Aggregate ingredients across recipes: deduplicate by normalized name, sum amounts in base units"
  gl3: "Display with check-off support: top-level hides all sub-items, sub-item reduces aggregate count"
  gl4: "Share as Markdown via Android share sheet"
  gl5: "Non-persistent: state resets between app sessions"

  gl1 -> gl1a -> gl2 -> gl3 -> gl4 -> gl5
}
